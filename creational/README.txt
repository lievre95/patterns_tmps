---->abstract_factory.py
В Java и других языках абстрактный шаблон фабрики служит интерфейсом для
создание связанных / зависимых объектов без необходимости указывать их
актуальный класс.

Идея состоит в том, чтобы абстрагировать создание объектов в зависимости от бизнеса
логика, выбор платформы и т. д.

В Python интерфейс, который мы используем, является просто вызываемым, то есть «встроенным» интерфейсом.
в Python, мы можем просто использовать сам класс как вызываемый, потому что классы являются первоклассными объектами в Python.

* Что делает этот пример?
Эта конкретная реализация абстрагирует создание домашнего животного и
делает это в зависимости от фабрики, которую мы выбрали (Dog или Cat, или random_animal)
Это работает, потому что как Dog / Cat, так и random_animal поддерживают общий
интерфейс (вызывается для создания и .speak ()).
Приложение может создавать абстрактно домашних животных и решать позже,
основываясь на критериях, собака это или кошка.

*Рекомендации:
https://sourcemaking.com/design_patterns/abstract_factory
http://ginstrom.com/scribbles/2007/10/08/design-patterns-python-style/


---->singleton.py
Паттерн Борг (Моностейт) - это способ реализовать одноэлементное поведение, но вместо одного экземпляра
класса, есть несколько экземпляров, которые разделяют одно и то же состояние.
Другими словами, акцент делается на совместное использование состояния вместо совместного использования экземпляра
как идентичность.

Чтобы понять реализацию этого шаблона в Python, важно знать, что в Python атрибуты экземпляра хранятся в
словаре атрибутов и называется __dict__. Обычно каждый экземпляр имеет
свой собственный словарь, но шаблон Борг изменяет это так, чтобы все экземпляры имеют один и тот же словарь.
__shared_state будет словарем распределяемым между всеми экземплярами, и это обеспечивается
__shared_state в переменной __dict__ при инициализации нового экземпляра .
 Другие атрибуты обычно добавлены в словарь атрибутов экземпляра, но, поскольку атрибут
со своим словарь является общим (то есть __shared_state), все остальные атрибуты также будут доступны.
По этой причине, когда атрибут self.state изменяется с помощью экземпляра rm2, а значение self.state в экземпляре
rm1 также изменяется.
То же самое происходит, если self.state модифицируется с помощью rm3, который является
экземпляром из подкласса.
Примичательно, что даже если они имеют общие атрибуты, экземпляры не будут теми же самыми, что видно по их идентификаторам.

*Рекомендации:
https://fkromer.github.io/python-pattern-references/design/#singleton


---->builder.py
Builder разъединяет создание сложного объекта и его представление,
так что один и тот же процесс может быть повторно использован для создания объектов из того же
семьи.
Это практично, если вы собираетесь отделить спецификацию объекта
от его фактического представления (как правило, для абстракции).

Данный пример использует класс для здания, где инициализатор (метод __init__) определяет
необходимые шаги, затем конкретные подклассы реализует эти шаги.
В общем, в Python питоне вы не столкнетесь с Полиморфизмом как на  C ++, так что можно расслабиться.

*Рекомендации:
https://sourcemaking.com/design_patterns/builder


---->factory_method.py
Шаблон Factory Method может быть использован для создания интерфейса для
метода, оставляя реализацию классу, который будет создан.

Пример показывает способ локализации слов на двух языках: английском и
Греческий. getLocalizer - это фабричный метод, который создает
локализатор в зависимости от выбранного языка. Объект локализатора станет экземпляром из другого класса в зависимости от языка.
Тем не менее,  коду все ровно, какие будет созданы экземпляры localizer, так как будет вызван метод "get"
и, таким образом, становится независим от языка.


Например, в контактной форме веб-страницы, тема и сообщение
поля создаются с использованием одной и той же фабрики форм (CharField ()), даже
хотя они имеют разные реализации в соответствии с их
целью.

*Рекомендации:
http://ginstrom.com/scribbles/2007/10/08/design-patterns-python-style/
https://fkromer.github.io/python-pattern-references/design/#factory-method
https://sourcemaking.com/design_patterns/factory_method

---->prototype.py
Эта модель направлена ​​на уменьшение количества классов, необходимых для  приложения.
 Вместо того, чтобы полагаться на подклассы, он создает объекты копированием прототипного экземпляра во время выполнения.

Этот пример полезен, так как облегчает получение новых видов объекта,
когда экземпляры класса имеют только несколько различных комбинационных
состояний. Это позволяет клиенту запрашивать у диспетчера прототип перед клонированием нового
примера.

Ниже приведен пример такого Диспетчера, который содержит три
копии прототипа: «default», «objecta» и «objectb».